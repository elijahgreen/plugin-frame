{"id":"UyRK","dependencies":[{"name":"/home/elijahgreen/projects/plugin-frame/examples/basic-example/package.json","includedInParent":true,"mtime":1632091987198},{"name":"/home/elijahgreen/projects/plugin-frame/examples/basic-example/node_modules/plugin-frame/package.json","includedInParent":true,"mtime":1632105404423}],"generated":{"js":"var define;\nvar n;function e(n){return(e=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&\"function\"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?\"symbol\":typeof n})(n)}function t(n,e,t,r,o,a,i){try{var s=n[a](i),c=s.value}catch(u){return void t(u)}s.done?e(c):Promise.resolve(c).then(r,o)}function r(n){return function(){var e=this,r=arguments;return new Promise(function(o,a){var i=n.apply(e,r);function s(n){t(i,o,a,s,c,\"next\",n)}function c(n){t(i,o,a,s,c,\"throw\",n)}s(void 0)})}}function o(n,e){return n(e={exports:{}},e.exports),e.exports}Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.PluginRemote=exports.PluginHost=void 0;var a=o(function(n){var t=function(n){var t,r=Object.prototype,o=r.hasOwnProperty,a=\"function\"==typeof Symbol?Symbol:{},i=a.iterator||\"@@iterator\",s=a.asyncIterator||\"@@asyncIterator\",c=a.toStringTag||\"@@toStringTag\";function u(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{u({},\"\")}catch(G){u=function(n,e,t){return n[e]=t}}function l(n,e,t,r){var o=e&&e.prototype instanceof g?e:g,a=Object.create(o.prototype),i=new M(r||[]);return a._invoke=function(n,e,t){var r=p;return function(o,a){if(r===f)throw new Error(\"Generator is already running\");if(r===m){if(\"throw\"===o)throw a;return I()}for(t.method=o,t.arg=a;;){var i=t.delegate;if(i){var s=P(i,t);if(s){if(s===y)continue;return s}}if(\"next\"===t.method)t.sent=t._sent=t.arg;else if(\"throw\"===t.method){if(r===p)throw r=m,t.arg;t.dispatchException(t.arg)}else\"return\"===t.method&&t.abrupt(\"return\",t.arg);r=f;var c=h(n,e,t);if(\"normal\"===c.type){if(r=t.done?m:d,c.arg===y)continue;return{value:c.arg,done:t.done}}\"throw\"===c.type&&(r=m,t.method=\"throw\",t.arg=c.arg)}}}(n,t,i),a}function h(n,e,t){try{return{type:\"normal\",arg:n.call(e,t)}}catch(G){return{type:\"throw\",arg:G}}}n.wrap=l;var p=\"suspendedStart\",d=\"suspendedYield\",f=\"executing\",m=\"completed\",y={};function g(){}function v(){}function x(){}var w={};u(w,i,function(){return this});var b=Object.getPrototypeOf,_=b&&b(b(j([])));_&&_!==r&&o.call(_,i)&&(w=_);var F=x.prototype=g.prototype=Object.create(w);function k(n){[\"next\",\"throw\",\"return\"].forEach(function(e){u(n,e,function(n){return this._invoke(e,n)})})}function E(n,t){var r;this._invoke=function(a,i){function s(){return new t(function(r,s){!function r(a,i,s,c){var u=h(n[a],n,i);if(\"throw\"!==u.type){var l=u.arg,p=l.value;return p&&\"object\"===e(p)&&o.call(p,\"__await\")?t.resolve(p.__await).then(function(n){r(\"next\",n,s,c)},function(n){r(\"throw\",n,s,c)}):t.resolve(p).then(function(n){l.value=n,s(l)},function(n){return r(\"throw\",n,s,c)})}c(u.arg)}(a,i,r,s)})}return r=r?r.then(s,s):s()}}function P(n,e){var r=n.iterator[e.method];if(r===t){if(e.delegate=null,\"throw\"===e.method){if(n.iterator.return&&(e.method=\"return\",e.arg=t,P(n,e),\"throw\"===e.method))return y;e.method=\"throw\",e.arg=new TypeError(\"The iterator does not provide a 'throw' method\")}return y}var o=h(r,n.iterator,e.arg);if(\"throw\"===o.type)return e.method=\"throw\",e.arg=o.arg,e.delegate=null,y;var a=o.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,\"return\"!==e.method&&(e.method=\"next\",e.arg=t),e.delegate=null,y):a:(e.method=\"throw\",e.arg=new TypeError(\"iterator result is not an object\"),e.delegate=null,y)}function L(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function S(n){var e=n.completion||{};e.type=\"normal\",delete e.arg,n.completion=e}function M(n){this.tryEntries=[{tryLoc:\"root\"}],n.forEach(L,this),this.reset(!0)}function j(n){if(n){var e=n[i];if(e)return e.call(n);if(\"function\"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,a=function e(){for(;++r<n.length;)if(o.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=t,e.done=!0,e};return a.next=a}}return{next:I}}function I(){return{value:t,done:!0}}return v.prototype=x,u(F,\"constructor\",x),u(x,\"constructor\",v),v.displayName=u(x,c,\"GeneratorFunction\"),n.isGeneratorFunction=function(n){var e=\"function\"==typeof n&&n.constructor;return!!e&&(e===v||\"GeneratorFunction\"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,x):(n.__proto__=x,u(n,c,\"GeneratorFunction\")),n.prototype=Object.create(F),n},n.awrap=function(n){return{__await:n}},k(E.prototype),u(E.prototype,s,function(){return this}),n.AsyncIterator=E,n.async=function(e,t,r,o,a){void 0===a&&(a=Promise);var i=new E(l(e,t,r,o),a);return n.isGeneratorFunction(t)?i:i.next().then(function(n){return n.done?n.value:i.next()})},k(F),u(F,c,\"Generator\"),u(F,i,function(){return this}),u(F,\"toString\",function(){return\"[object Generator]\"}),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=j,M.prototype={constructor:M,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method=\"next\",this.arg=t,this.tryEntries.forEach(S),!n)for(var e in this)\"t\"===e.charAt(0)&&o.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=t)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if(\"throw\"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(r,o){return s.type=\"throw\",s.arg=n,e.next=r,o&&(e.method=\"next\",e.arg=t),!!o}for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a],s=i.completion;if(\"root\"===i.tryLoc)return r(\"end\");if(i.tryLoc<=this.prev){var c=o.call(i,\"catchLoc\"),u=o.call(i,\"finallyLoc\");if(c&&u){if(this.prev<i.catchLoc)return r(i.catchLoc,!0);if(this.prev<i.finallyLoc)return r(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return r(i.catchLoc,!0)}else{if(!u)throw new Error(\"try statement without catch or finally\");if(this.prev<i.finallyLoc)return r(i.finallyLoc)}}}},abrupt:function(n,e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc<=this.prev&&o.call(r,\"finallyLoc\")&&this.prev<r.finallyLoc){var a=r;break}}a&&(\"break\"===n||\"continue\"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=n,i.arg=e,a?(this.method=\"next\",this.next=a.finallyLoc,y):this.complete(i)},complete:function(n,e){if(\"throw\"===n.type)throw n.arg;return\"break\"===n.type||\"continue\"===n.type?this.next=n.arg:\"return\"===n.type?(this.rval=this.arg=n.arg,this.method=\"return\",this.next=\"end\"):\"normal\"===n.type&&e&&(this.next=e),y},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),S(t),y}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if(\"throw\"===r.type){var o=r.arg;S(t)}return o}}throw new Error(\"illegal catch attempt\")},delegateYield:function(n,e,r){return this.delegate={iterator:j(n),resultName:e,nextLoc:r},\"next\"===this.method&&(this.arg=t),y}},n}(n.exports);try{regeneratorRuntime=t}catch(r){\"object\"===(\"undefined\"==typeof globalThis?\"undefined\":e(globalThis))?globalThis.regeneratorRuntime=t:Function(\"r\",\"regeneratorRuntime = r\")(t)}}),i=function(){function n(n,e,t,r){this.remoteMethods=[],this.options={useCompiled:!1,container:document.body},this.child={},this.isReady=!1,this.readyFuncs=[],this.compiled='function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\\n  try {\\n    var info = gen[key](arg);\\n    var value = info.value;\\n  } catch (error) {\\n    reject(error);\\n    return;\\n  }\\n\\n  if (info.done) {\\n    resolve(value);\\n  } else {\\n    Promise.resolve(value).then(_next, _throw);\\n  }\\n}\\n\\nfunction _asyncToGenerator(fn) {\\n  return function () {\\n    var self = this,\\n        args = arguments;\\n    return new Promise(function (resolve, reject) {\\n      var gen = fn.apply(self, args);\\n\\n      function _next(value) {\\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\\n      }\\n\\n      function _throw(err) {\\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\\n      }\\n\\n      _next(undefined);\\n    });\\n  };\\n}\\n\\nfunction createCommonjsModule(fn, module) {\\n\\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\\n}\\n\\nvar runtime_1 = createCommonjsModule(function (module) {\\n/**\\n * Copyright (c) 2014-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\nvar runtime = (function (exports) {\\n\\n  var Op = Object.prototype;\\n  var hasOwn = Op.hasOwnProperty;\\n  var undefined$1; // More compressible than void 0.\\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\\n\\n  function define(obj, key, value) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n    return obj[key];\\n  }\\n  try {\\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\\n    define({}, \"\");\\n  } catch (err) {\\n    define = function(obj, key, value) {\\n      return obj[key] = value;\\n    };\\n  }\\n\\n  function wrap(innerFn, outerFn, self, tryLocsList) {\\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\\n    var generator = Object.create(protoGenerator.prototype);\\n    var context = new Context(tryLocsList || []);\\n\\n    // The ._invoke method unifies the implementations of the .next,\\n    // .throw, and .return methods.\\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\\n\\n    return generator;\\n  }\\n  exports.wrap = wrap;\\n\\n  // Try/catch helper to minimize deoptimizations. Returns a completion\\n  // record like context.tryEntries[i].completion. This interface could\\n  // have been (and was previously) designed to take a closure to be\\n  // invoked without arguments, but in all the cases we care about we\\n  // already have an existing method we want to call, so there\\'s no need\\n  // to create a new function object. We can even get away with assuming\\n  // the method takes exactly one argument, since that happens to be true\\n  // in every case, so we don\\'t have to touch the arguments object. The\\n  // only additional allocation required is the completion record, which\\n  // has a stable shape and so hopefully should be cheap to allocate.\\n  function tryCatch(fn, obj, arg) {\\n    try {\\n      return { type: \"normal\", arg: fn.call(obj, arg) };\\n    } catch (err) {\\n      return { type: \"throw\", arg: err };\\n    }\\n  }\\n\\n  var GenStateSuspendedStart = \"suspendedStart\";\\n  var GenStateSuspendedYield = \"suspendedYield\";\\n  var GenStateExecuting = \"executing\";\\n  var GenStateCompleted = \"completed\";\\n\\n  // Returning this object from the innerFn has the same effect as\\n  // breaking out of the dispatch switch statement.\\n  var ContinueSentinel = {};\\n\\n  // Dummy constructor functions that we use as the .constructor and\\n  // .constructor.prototype properties for functions that return Generator\\n  // objects. For full spec compliance, you may wish to configure your\\n  // minifier not to mangle the names of these two functions.\\n  function Generator() {}\\n  function GeneratorFunction() {}\\n  function GeneratorFunctionPrototype() {}\\n\\n  // This is a polyfill for %IteratorPrototype% for environments that\\n  // don\\'t natively support it.\\n  var IteratorPrototype = {};\\n  define(IteratorPrototype, iteratorSymbol, function () {\\n    return this;\\n  });\\n\\n  var getProto = Object.getPrototypeOf;\\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\\n  if (NativeIteratorPrototype &&\\n      NativeIteratorPrototype !== Op &&\\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\\n    // This environment has a native %IteratorPrototype%; use it instead\\n    // of the polyfill.\\n    IteratorPrototype = NativeIteratorPrototype;\\n  }\\n\\n  var Gp = GeneratorFunctionPrototype.prototype =\\n    Generator.prototype = Object.create(IteratorPrototype);\\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\\n  GeneratorFunction.displayName = define(\\n    GeneratorFunctionPrototype,\\n    toStringTagSymbol,\\n    \"GeneratorFunction\"\\n  );\\n\\n  // Helper for defining the .next, .throw, and .return methods of the\\n  // Iterator interface in terms of a single ._invoke method.\\n  function defineIteratorMethods(prototype) {\\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\\n      define(prototype, method, function(arg) {\\n        return this._invoke(method, arg);\\n      });\\n    });\\n  }\\n\\n  exports.isGeneratorFunction = function(genFun) {\\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\\n    return ctor\\n      ? ctor === GeneratorFunction ||\\n        // For the native GeneratorFunction constructor, the best we can\\n        // do is to check its .name property.\\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\\n      : false;\\n  };\\n\\n  exports.mark = function(genFun) {\\n    if (Object.setPrototypeOf) {\\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\\n    } else {\\n      genFun.__proto__ = GeneratorFunctionPrototype;\\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\\n    }\\n    genFun.prototype = Object.create(Gp);\\n    return genFun;\\n  };\\n\\n  // Within the body of any async function, `await x` is transformed to\\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\\n  // meant to be awaited.\\n  exports.awrap = function(arg) {\\n    return { __await: arg };\\n  };\\n\\n  function AsyncIterator(generator, PromiseImpl) {\\n    function invoke(method, arg, resolve, reject) {\\n      var record = tryCatch(generator[method], generator, arg);\\n      if (record.type === \"throw\") {\\n        reject(record.arg);\\n      } else {\\n        var result = record.arg;\\n        var value = result.value;\\n        if (value &&\\n            typeof value === \"object\" &&\\n            hasOwn.call(value, \"__await\")) {\\n          return PromiseImpl.resolve(value.__await).then(function(value) {\\n            invoke(\"next\", value, resolve, reject);\\n          }, function(err) {\\n            invoke(\"throw\", err, resolve, reject);\\n          });\\n        }\\n\\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\\n          // When a yielded Promise is resolved, its final value becomes\\n          // the .value of the Promise<{value,done}> result for the\\n          // current iteration.\\n          result.value = unwrapped;\\n          resolve(result);\\n        }, function(error) {\\n          // If a rejected Promise was yielded, throw the rejection back\\n          // into the async generator function so it can be handled there.\\n          return invoke(\"throw\", error, resolve, reject);\\n        });\\n      }\\n    }\\n\\n    var previousPromise;\\n\\n    function enqueue(method, arg) {\\n      function callInvokeWithMethodAndArg() {\\n        return new PromiseImpl(function(resolve, reject) {\\n          invoke(method, arg, resolve, reject);\\n        });\\n      }\\n\\n      return previousPromise =\\n        // If enqueue has been called before, then we want to wait until\\n        // all previous Promises have been resolved before calling invoke,\\n        // so that results are always delivered in the correct order. If\\n        // enqueue has not been called before, then it is important to\\n        // call invoke immediately, without waiting on a callback to fire,\\n        // so that the async generator function has the opportunity to do\\n        // any necessary setup in a predictable way. This predictability\\n        // is why the Promise constructor synchronously invokes its\\n        // executor callback, and why async functions synchronously\\n        // execute code before the first await. Since we implement simple\\n        // async functions in terms of async generators, it is especially\\n        // important to get this right, even though it requires care.\\n        previousPromise ? previousPromise.then(\\n          callInvokeWithMethodAndArg,\\n          // Avoid propagating failures to Promises returned by later\\n          // invocations of the iterator.\\n          callInvokeWithMethodAndArg\\n        ) : callInvokeWithMethodAndArg();\\n    }\\n\\n    // Define the unified helper method that is used to implement .next,\\n    // .throw, and .return (see defineIteratorMethods).\\n    this._invoke = enqueue;\\n  }\\n\\n  defineIteratorMethods(AsyncIterator.prototype);\\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\\n    return this;\\n  });\\n  exports.AsyncIterator = AsyncIterator;\\n\\n  // Note that simple async functions are implemented on top of\\n  // AsyncIterator objects; they just return a Promise for the value of\\n  // the final result produced by the iterator.\\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\\n\\n    var iter = new AsyncIterator(\\n      wrap(innerFn, outerFn, self, tryLocsList),\\n      PromiseImpl\\n    );\\n\\n    return exports.isGeneratorFunction(outerFn)\\n      ? iter // If outerFn is a generator, return the full iterator.\\n      : iter.next().then(function(result) {\\n          return result.done ? result.value : iter.next();\\n        });\\n  };\\n\\n  function makeInvokeMethod(innerFn, self, context) {\\n    var state = GenStateSuspendedStart;\\n\\n    return function invoke(method, arg) {\\n      if (state === GenStateExecuting) {\\n        throw new Error(\"Generator is already running\");\\n      }\\n\\n      if (state === GenStateCompleted) {\\n        if (method === \"throw\") {\\n          throw arg;\\n        }\\n\\n        // Be forgiving, per 25.3.3.3.3 of the spec:\\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\\n        return doneResult();\\n      }\\n\\n      context.method = method;\\n      context.arg = arg;\\n\\n      while (true) {\\n        var delegate = context.delegate;\\n        if (delegate) {\\n          var delegateResult = maybeInvokeDelegate(delegate, context);\\n          if (delegateResult) {\\n            if (delegateResult === ContinueSentinel) continue;\\n            return delegateResult;\\n          }\\n        }\\n\\n        if (context.method === \"next\") {\\n          // Setting context._sent for legacy support of Babel\\'s\\n          // function.sent implementation.\\n          context.sent = context._sent = context.arg;\\n\\n        } else if (context.method === \"throw\") {\\n          if (state === GenStateSuspendedStart) {\\n            state = GenStateCompleted;\\n            throw context.arg;\\n          }\\n\\n          context.dispatchException(context.arg);\\n\\n        } else if (context.method === \"return\") {\\n          context.abrupt(\"return\", context.arg);\\n        }\\n\\n        state = GenStateExecuting;\\n\\n        var record = tryCatch(innerFn, self, context);\\n        if (record.type === \"normal\") {\\n          // If an exception is thrown from innerFn, we leave state ===\\n          // GenStateExecuting and loop back for another invocation.\\n          state = context.done\\n            ? GenStateCompleted\\n            : GenStateSuspendedYield;\\n\\n          if (record.arg === ContinueSentinel) {\\n            continue;\\n          }\\n\\n          return {\\n            value: record.arg,\\n            done: context.done\\n          };\\n\\n        } else if (record.type === \"throw\") {\\n          state = GenStateCompleted;\\n          // Dispatch the exception by looping back around to the\\n          // context.dispatchException(context.arg) call above.\\n          context.method = \"throw\";\\n          context.arg = record.arg;\\n        }\\n      }\\n    };\\n  }\\n\\n  // Call delegate.iterator[context.method](context.arg) and handle the\\n  // result, either by returning a { value, done } result from the\\n  // delegate iterator, or by modifying context.method and context.arg,\\n  // setting context.delegate to null, and returning the ContinueSentinel.\\n  function maybeInvokeDelegate(delegate, context) {\\n    var method = delegate.iterator[context.method];\\n    if (method === undefined$1) {\\n      // A .throw or .return when the delegate iterator has no .throw\\n      // method always terminates the yield* loop.\\n      context.delegate = null;\\n\\n      if (context.method === \"throw\") {\\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\\n        if (delegate.iterator[\"return\"]) {\\n          // If the delegate iterator has a return method, give it a\\n          // chance to clean up.\\n          context.method = \"return\";\\n          context.arg = undefined$1;\\n          maybeInvokeDelegate(delegate, context);\\n\\n          if (context.method === \"throw\") {\\n            // If maybeInvokeDelegate(context) changed context.method from\\n            // \"return\" to \"throw\", let that override the TypeError below.\\n            return ContinueSentinel;\\n          }\\n        }\\n\\n        context.method = \"throw\";\\n        context.arg = new TypeError(\\n          \"The iterator does not provide a \\'throw\\' method\");\\n      }\\n\\n      return ContinueSentinel;\\n    }\\n\\n    var record = tryCatch(method, delegate.iterator, context.arg);\\n\\n    if (record.type === \"throw\") {\\n      context.method = \"throw\";\\n      context.arg = record.arg;\\n      context.delegate = null;\\n      return ContinueSentinel;\\n    }\\n\\n    var info = record.arg;\\n\\n    if (! info) {\\n      context.method = \"throw\";\\n      context.arg = new TypeError(\"iterator result is not an object\");\\n      context.delegate = null;\\n      return ContinueSentinel;\\n    }\\n\\n    if (info.done) {\\n      // Assign the result of the finished delegate to the temporary\\n      // variable specified by delegate.resultName (see delegateYield).\\n      context[delegate.resultName] = info.value;\\n\\n      // Resume execution at the desired location (see delegateYield).\\n      context.next = delegate.nextLoc;\\n\\n      // If context.method was \"throw\" but the delegate handled the\\n      // exception, let the outer generator proceed normally. If\\n      // context.method was \"next\", forget context.arg since it has been\\n      // \"consumed\" by the delegate iterator. If context.method was\\n      // \"return\", allow the original .return call to continue in the\\n      // outer generator.\\n      if (context.method !== \"return\") {\\n        context.method = \"next\";\\n        context.arg = undefined$1;\\n      }\\n\\n    } else {\\n      // Re-yield the result returned by the delegate method.\\n      return info;\\n    }\\n\\n    // The delegate iterator is finished, so forget it and continue with\\n    // the outer generator.\\n    context.delegate = null;\\n    return ContinueSentinel;\\n  }\\n\\n  // Define Generator.prototype.{next,throw,return} in terms of the\\n  // unified ._invoke helper method.\\n  defineIteratorMethods(Gp);\\n\\n  define(Gp, toStringTagSymbol, \"Generator\");\\n\\n  // A Generator should always return itself as the iterator object when the\\n  // @@iterator function is called on it. Some browsers\\' implementations of the\\n  // iterator prototype chain incorrectly implement this, causing the Generator\\n  // object to not be returned from this call. This ensures that doesn\\'t happen.\\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\\n  define(Gp, iteratorSymbol, function() {\\n    return this;\\n  });\\n\\n  define(Gp, \"toString\", function() {\\n    return \"[object Generator]\";\\n  });\\n\\n  function pushTryEntry(locs) {\\n    var entry = { tryLoc: locs[0] };\\n\\n    if (1 in locs) {\\n      entry.catchLoc = locs[1];\\n    }\\n\\n    if (2 in locs) {\\n      entry.finallyLoc = locs[2];\\n      entry.afterLoc = locs[3];\\n    }\\n\\n    this.tryEntries.push(entry);\\n  }\\n\\n  function resetTryEntry(entry) {\\n    var record = entry.completion || {};\\n    record.type = \"normal\";\\n    delete record.arg;\\n    entry.completion = record;\\n  }\\n\\n  function Context(tryLocsList) {\\n    // The root entry object (effectively a try statement without a catch\\n    // or a finally block) gives us a place to store values thrown from\\n    // locations where there is no enclosing try statement.\\n    this.tryEntries = [{ tryLoc: \"root\" }];\\n    tryLocsList.forEach(pushTryEntry, this);\\n    this.reset(true);\\n  }\\n\\n  exports.keys = function(object) {\\n    var keys = [];\\n    for (var key in object) {\\n      keys.push(key);\\n    }\\n    keys.reverse();\\n\\n    // Rather than returning an object with a next method, we keep\\n    // things simple and return the next function itself.\\n    return function next() {\\n      while (keys.length) {\\n        var key = keys.pop();\\n        if (key in object) {\\n          next.value = key;\\n          next.done = false;\\n          return next;\\n        }\\n      }\\n\\n      // To avoid creating an additional object, we just hang the .value\\n      // and .done properties off the next function object itself. This\\n      // also ensures that the minifier will not anonymize the function.\\n      next.done = true;\\n      return next;\\n    };\\n  };\\n\\n  function values(iterable) {\\n    if (iterable) {\\n      var iteratorMethod = iterable[iteratorSymbol];\\n      if (iteratorMethod) {\\n        return iteratorMethod.call(iterable);\\n      }\\n\\n      if (typeof iterable.next === \"function\") {\\n        return iterable;\\n      }\\n\\n      if (!isNaN(iterable.length)) {\\n        var i = -1, next = function next() {\\n          while (++i < iterable.length) {\\n            if (hasOwn.call(iterable, i)) {\\n              next.value = iterable[i];\\n              next.done = false;\\n              return next;\\n            }\\n          }\\n\\n          next.value = undefined$1;\\n          next.done = true;\\n\\n          return next;\\n        };\\n\\n        return next.next = next;\\n      }\\n    }\\n\\n    // Return an iterator with no values.\\n    return { next: doneResult };\\n  }\\n  exports.values = values;\\n\\n  function doneResult() {\\n    return { value: undefined$1, done: true };\\n  }\\n\\n  Context.prototype = {\\n    constructor: Context,\\n\\n    reset: function(skipTempReset) {\\n      this.prev = 0;\\n      this.next = 0;\\n      // Resetting context._sent for legacy support of Babel\\'s\\n      // function.sent implementation.\\n      this.sent = this._sent = undefined$1;\\n      this.done = false;\\n      this.delegate = null;\\n\\n      this.method = \"next\";\\n      this.arg = undefined$1;\\n\\n      this.tryEntries.forEach(resetTryEntry);\\n\\n      if (!skipTempReset) {\\n        for (var name in this) {\\n          // Not sure about the optimal order of these conditions:\\n          if (name.charAt(0) === \"t\" &&\\n              hasOwn.call(this, name) &&\\n              !isNaN(+name.slice(1))) {\\n            this[name] = undefined$1;\\n          }\\n        }\\n      }\\n    },\\n\\n    stop: function() {\\n      this.done = true;\\n\\n      var rootEntry = this.tryEntries[0];\\n      var rootRecord = rootEntry.completion;\\n      if (rootRecord.type === \"throw\") {\\n        throw rootRecord.arg;\\n      }\\n\\n      return this.rval;\\n    },\\n\\n    dispatchException: function(exception) {\\n      if (this.done) {\\n        throw exception;\\n      }\\n\\n      var context = this;\\n      function handle(loc, caught) {\\n        record.type = \"throw\";\\n        record.arg = exception;\\n        context.next = loc;\\n\\n        if (caught) {\\n          // If the dispatched exception was caught by a catch block,\\n          // then let that catch block handle the exception normally.\\n          context.method = \"next\";\\n          context.arg = undefined$1;\\n        }\\n\\n        return !! caught;\\n      }\\n\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        var record = entry.completion;\\n\\n        if (entry.tryLoc === \"root\") {\\n          // Exception thrown outside of any try block that could handle\\n          // it, so set the completion value of the entire function to\\n          // throw the exception.\\n          return handle(\"end\");\\n        }\\n\\n        if (entry.tryLoc <= this.prev) {\\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\\n\\n          if (hasCatch && hasFinally) {\\n            if (this.prev < entry.catchLoc) {\\n              return handle(entry.catchLoc, true);\\n            } else if (this.prev < entry.finallyLoc) {\\n              return handle(entry.finallyLoc);\\n            }\\n\\n          } else if (hasCatch) {\\n            if (this.prev < entry.catchLoc) {\\n              return handle(entry.catchLoc, true);\\n            }\\n\\n          } else if (hasFinally) {\\n            if (this.prev < entry.finallyLoc) {\\n              return handle(entry.finallyLoc);\\n            }\\n\\n          } else {\\n            throw new Error(\"try statement without catch or finally\");\\n          }\\n        }\\n      }\\n    },\\n\\n    abrupt: function(type, arg) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.tryLoc <= this.prev &&\\n            hasOwn.call(entry, \"finallyLoc\") &&\\n            this.prev < entry.finallyLoc) {\\n          var finallyEntry = entry;\\n          break;\\n        }\\n      }\\n\\n      if (finallyEntry &&\\n          (type === \"break\" ||\\n           type === \"continue\") &&\\n          finallyEntry.tryLoc <= arg &&\\n          arg <= finallyEntry.finallyLoc) {\\n        // Ignore the finally entry if control is not jumping to a\\n        // location outside the try/catch block.\\n        finallyEntry = null;\\n      }\\n\\n      var record = finallyEntry ? finallyEntry.completion : {};\\n      record.type = type;\\n      record.arg = arg;\\n\\n      if (finallyEntry) {\\n        this.method = \"next\";\\n        this.next = finallyEntry.finallyLoc;\\n        return ContinueSentinel;\\n      }\\n\\n      return this.complete(record);\\n    },\\n\\n    complete: function(record, afterLoc) {\\n      if (record.type === \"throw\") {\\n        throw record.arg;\\n      }\\n\\n      if (record.type === \"break\" ||\\n          record.type === \"continue\") {\\n        this.next = record.arg;\\n      } else if (record.type === \"return\") {\\n        this.rval = this.arg = record.arg;\\n        this.method = \"return\";\\n        this.next = \"end\";\\n      } else if (record.type === \"normal\" && afterLoc) {\\n        this.next = afterLoc;\\n      }\\n\\n      return ContinueSentinel;\\n    },\\n\\n    finish: function(finallyLoc) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.finallyLoc === finallyLoc) {\\n          this.complete(entry.completion, entry.afterLoc);\\n          resetTryEntry(entry);\\n          return ContinueSentinel;\\n        }\\n      }\\n    },\\n\\n    \"catch\": function(tryLoc) {\\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\\n        var entry = this.tryEntries[i];\\n        if (entry.tryLoc === tryLoc) {\\n          var record = entry.completion;\\n          if (record.type === \"throw\") {\\n            var thrown = record.arg;\\n            resetTryEntry(entry);\\n          }\\n          return thrown;\\n        }\\n      }\\n\\n      // The context.catch method must only be called with a location\\n      // argument that corresponds to a known catch block.\\n      throw new Error(\"illegal catch attempt\");\\n    },\\n\\n    delegateYield: function(iterable, resultName, nextLoc) {\\n      this.delegate = {\\n        iterator: values(iterable),\\n        resultName: resultName,\\n        nextLoc: nextLoc\\n      };\\n\\n      if (this.method === \"next\") {\\n        // Deliberately forget the last sent value so that we don\\'t\\n        // accidentally pass it on to the delegate.\\n        this.arg = undefined$1;\\n      }\\n\\n      return ContinueSentinel;\\n    }\\n  };\\n\\n  // Regardless of whether this script is executing as a CommonJS module\\n  // or not, return the runtime object so that we can declare the variable\\n  // regeneratorRuntime in the outer scope, which allows this module to be\\n  // injected easily by `bin/regenerator --include-runtime script.js`.\\n  return exports;\\n\\n}(\\n  // If this script is executing as a CommonJS module, use module.exports\\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\\n  // object. Either way, the resulting object will be used to initialize\\n  // the regeneratorRuntime variable at the top of this file.\\n   module.exports \\n));\\n\\ntry {\\n  regeneratorRuntime = runtime;\\n} catch (accidentalStrictMode) {\\n  // This module should not be running in strict mode, so the above\\n  // assignment should always work unless something is misconfigured. Just\\n  // in case runtime.js accidentally runs in strict mode, in modern engines\\n  // we can explicitly access globalThis. In older engines we can escape\\n  // strict mode using a global Function call. This could conceivably fail\\n  // if a Content Security Policy forbids using Function, but in that case\\n  // the proper solution is to fix the accidental strict mode problem. If\\n  // you\\'ve misconfigured your bundler to force strict mode and applied a\\n  // CSP to forbid Function, and you\\'re not willing to fix either of those\\n  // problems, please detail your unique predicament in a GitHub issue.\\n  if (typeof globalThis === \"object\") {\\n    globalThis.regeneratorRuntime = runtime;\\n  } else {\\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\\n  }\\n}\\n});\\n\\nvar PluginHost = /*#__PURE__*/function () {\\n  function PluginHost(host, code, api, options) {\\n    this.remoteMethods = [];\\n    this.options = {\\n      useCompiled: false,\\n      container: document.body\\n    };\\n    this.child = {};\\n    this.isReady = false;\\n    this.readyFuncs = [];\\n    this.compiled = \"<TEMPLATE>\";\\n    this.remoteOrigin = host.origin;\\n    this.host = host;\\n    this.code = code;\\n    this.api = api;\\n    this.options = options || this.options;\\n    this.container = options == null ? void 0 : options.container;\\n    this.iframe = this.createIframe();\\n  }\\n\\n  var _proto = PluginHost.prototype;\\n\\n  _proto.createIframe = function createIframe() {\\n    var iframe = document.createElement(\\'iframe\\');\\n    iframe.frameBorder = \\'0\\';\\n    iframe.width = \\'0\\';\\n    iframe.height = \\'0\\';\\n    iframe.src = this.host.href;\\n    iframe.sandbox.add(\\'allow-scripts\\');\\n    iframe.sandbox.add(\\'allow-same-origin\\');\\n    iframe.onload = this.iframeOnLoad.bind(this);\\n\\n    if (this.container) {\\n      this.container.append(iframe);\\n    } else {\\n      document.body.append(iframe);\\n    }\\n\\n    if (this.options.useCompiled) {\\n      console.log(this.compiled);\\n    }\\n\\n    return iframe;\\n  };\\n\\n  _proto.portOnMessage = /*#__PURE__*/function () {\\n    var _portOnMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(event) {\\n      var name, method, args, result;\\n      return runtime_1.wrap(function _callee$(_context) {\\n        while (1) {\\n          switch (_context.prev = _context.next) {\\n            case 0:\\n              _context.t0 = event.data.type;\\n              _context.next = _context.t0 === \\'events\\' ? 3 : _context.t0 === \\'method\\' ? 7 : 22;\\n              break;\\n\\n            case 3:\\n              this.remoteMethods = event.data.api;\\n              this.createFunctions();\\n              this.connected();\\n              return _context.abrupt(\"break\", 22);\\n\\n            case 7:\\n              _context.prev = 7;\\n              name = event.data.name;\\n              method = this.api[name];\\n              args = event.data.args;\\n              _context.next = 13;\\n              return method.apply(null, args);\\n\\n            case 13:\\n              result = _context.sent;\\n              event.ports[0].postMessage({\\n                result: result\\n              });\\n              _context.next = 21;\\n              break;\\n\\n            case 17:\\n              _context.prev = 17;\\n              _context.t1 = _context[\"catch\"](7);\\n              console.log(_context.t1);\\n              event.ports[0].postMessage({\\n                error: _context.t1\\n              });\\n\\n            case 21:\\n              return _context.abrupt(\"break\", 22);\\n\\n            case 22:\\n            case \"end\":\\n              return _context.stop();\\n          }\\n        }\\n      }, _callee, this, [[7, 17]]);\\n    }));\\n\\n    function portOnMessage(_x) {\\n      return _portOnMessage.apply(this, arguments);\\n    }\\n\\n    return portOnMessage;\\n  }();\\n\\n  _proto.iframeOnLoad = function iframeOnLoad() {\\n    var _this$iframe$contentW, _this$iframe$contentW2;\\n\\n    var channel = new MessageChannel();\\n    this.port = channel.port1;\\n    this.port.onmessage = this.portOnMessage.bind(this);\\n    var names = [];\\n\\n    for (var name in this.api) {\\n      if (this.api.hasOwnProperty(name)) {\\n        names.push(name);\\n      }\\n    }\\n\\n    (_this$iframe$contentW = this.iframe.contentWindow) == null ? void 0 : _this$iframe$contentW.postMessage({\\n      type: \\'init\\',\\n      api: names\\n    }, this.remoteOrigin, [channel.port2]);\\n    (_this$iframe$contentW2 = this.iframe.contentWindow) == null ? void 0 : _this$iframe$contentW2.postMessage({\\n      type: \\'init-eval\\',\\n      data: this.code\\n    }, this.remoteOrigin);\\n  };\\n\\n  _proto.generateFunction = function generateFunction(name) {\\n    var _this = this;\\n\\n    var newFunc = function newFunc() {\\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n        args[_key] = arguments[_key];\\n      }\\n\\n      return new Promise(function (res, rej) {\\n        var _this$port;\\n\\n        var channel = new MessageChannel();\\n\\n        channel.port1.onmessage = function (_ref) {\\n          var data = _ref.data;\\n          channel.port1.close();\\n\\n          if (data.error) {\\n            rej(data.error);\\n          } else {\\n            res(data.result);\\n          }\\n        };\\n\\n        (_this$port = _this.port) == null ? void 0 : _this$port.postMessage({\\n          type: \\'method\\',\\n          name: name,\\n          args: args\\n        }, [channel.port2]);\\n      });\\n    };\\n\\n    return newFunc;\\n  };\\n\\n  _proto.createFunctions = function createFunctions() {\\n    var _this2 = this;\\n\\n    this.remoteMethods.forEach(function (name) {\\n      _this2.child[name] = _this2.generateFunction(name);\\n    });\\n  };\\n\\n  _proto.methodNameExists = function methodNameExists(name) {\\n    var _this3 = this;\\n\\n    return new Promise(function (res, rej) {\\n      var _this3$port;\\n\\n      var channel = new MessageChannel();\\n\\n      channel.port1.onmessage = function (_ref2) {\\n        var data = _ref2.data;\\n        channel.port1.close();\\n\\n        if (data.error) {\\n          rej(data.error);\\n        } else {\\n          res(data.result);\\n        }\\n      };\\n\\n      (_this3$port = _this3.port) == null ? void 0 : _this3$port.postMessage({\\n        type: \\'exists\\',\\n        name: name\\n      }, [channel.port2]);\\n    });\\n  };\\n\\n  _proto.ready = function ready(readyFunc) {\\n    if (this.isReady) {\\n      readyFunc();\\n    } else {\\n      this.readyFuncs.push(readyFunc);\\n    }\\n  };\\n\\n  _proto.connected = function connected() {\\n    this.isReady = true;\\n    this.readyFuncs.forEach(function (f) {\\n      f();\\n    });\\n  };\\n\\n  return PluginHost;\\n}();\\n\\nvar application = {};\\nvar PluginRemote = /*#__PURE__*/function () {\\n  function PluginRemote(api, options) {\\n    this.hostMethods = [];\\n    window.addEventListener(\\'message\\', this.initPort.bind(this));\\n    this.prepareFuncs = options == null ? void 0 : options.prepareFuncs;\\n    this.completeFuncs = options == null ? void 0 : options.completeFuncs;\\n    this.api = api;\\n  }\\n\\n  var _proto = PluginRemote.prototype;\\n\\n  _proto.onMessage = /*#__PURE__*/function () {\\n    var _onMessage = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(event) {\\n      var name, method, args, result, exists;\\n      return runtime_1.wrap(function _callee$(_context) {\\n        while (1) {\\n          switch (_context.prev = _context.next) {\\n            case 0:\\n              _context.t0 = event.data.type;\\n              _context.next = _context.t0 === \\'method\\' ? 3 : _context.t0 === \\'exists\\' ? 17 : 19;\\n              break;\\n\\n            case 3:\\n              _context.prev = 3;\\n              name = event.data.name;\\n              method = this.api[name];\\n              args = event.data.args;\\n              _context.next = 9;\\n              return method.apply(null, args);\\n\\n            case 9:\\n              result = _context.sent;\\n              event.ports[0].postMessage({\\n                result: result\\n              });\\n              _context.next = 16;\\n              break;\\n\\n            case 13:\\n              _context.prev = 13;\\n              _context.t1 = _context[\"catch\"](3);\\n              event.ports[0].postMessage({\\n                error: _context.t1\\n              });\\n\\n            case 16:\\n              return _context.abrupt(\"break\", 19);\\n\\n            case 17:\\n              try {\\n                exists = !!application[event.data.name];\\n                event.ports[0].postMessage({\\n                  result: exists\\n                });\\n              } catch (e) {\\n                event.ports[0].postMessage({\\n                  error: e\\n                });\\n              }\\n\\n              return _context.abrupt(\"break\", 19);\\n\\n            case 19:\\n            case \"end\":\\n              return _context.stop();\\n          }\\n        }\\n      }, _callee, this, [[3, 13]]);\\n    }));\\n\\n    function onMessage(_x) {\\n      return _onMessage.apply(this, arguments);\\n    }\\n\\n    return onMessage;\\n  }();\\n\\n  _proto.initializeApi = function initializeApi() {\\n    var _this$port;\\n\\n    var names = [];\\n\\n    for (var name in this.api) {\\n      if (this.api.hasOwnProperty(name)) {\\n        names.push(name);\\n      }\\n    }\\n\\n    (_this$port = this.port) == null ? void 0 : _this$port.postMessage({\\n      type: \\'events\\',\\n      api: names\\n    });\\n  };\\n\\n  _proto.generateFunction = function generateFunction(name) {\\n    var _this = this;\\n\\n    var newFunc = function newFunc() {\\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n        args[_key] = arguments[_key];\\n      }\\n\\n      return new Promise(function (res, rej) {\\n        var _this$port2;\\n\\n        var channel = new MessageChannel();\\n\\n        channel.port1.onmessage = function (_ref) {\\n          var data = _ref.data;\\n          channel.port1.close();\\n\\n          if (data.error) {\\n            rej(data.error);\\n          } else {\\n            var result = data.result;\\n\\n            if (_this.completeFuncs && _this.completeFuncs[name]) {\\n              result = _this.completeFuncs[name](result);\\n            }\\n\\n            res(result);\\n          }\\n        };\\n\\n        if (_this.prepareFuncs && _this.prepareFuncs[name]) {\\n          args = _this.prepareFuncs[name](args);\\n        }\\n\\n        (_this$port2 = _this.port) == null ? void 0 : _this$port2.postMessage({\\n          type: \\'method\\',\\n          name: name,\\n          args: args\\n        }, [channel.port2]);\\n      });\\n    };\\n\\n    return newFunc;\\n  };\\n\\n  _proto.createFunctions = function createFunctions() {\\n    var _this2 = this;\\n\\n    this.hostMethods.forEach(function (name) {\\n      application[name] = _this2.generateFunction(name);\\n    });\\n  };\\n\\n  _proto.initPort = function initPort(event) {\\n    var _document$getElementB;\\n\\n    switch (event.data.type) {\\n      case \\'init\\':\\n        this.port = event.ports[0];\\n        this.port.onmessage = this.onMessage.bind(this);\\n        this.hostMethods = event.data.api;\\n        this.initializeApi();\\n        this.createFunctions();\\n        break;\\n\\n      case \\'init-eval\\':\\n        var scriptTag = document.createElement(\\'script\\');\\n        scriptTag.innerHTML = event.data.data;\\n        (_document$getElementB = document.getElementById(\\'head\\')) == null ? void 0 : _document$getElementB.appendChild(scriptTag);\\n        break;\\n    }\\n  };\\n\\n  return PluginRemote;\\n}();\\n\\nexport { PluginHost, PluginRemote };\\n',this.remoteOrigin=n.origin,this.host=n,this.code=e,this.api=t,this.options=r||this.options,this.container=null==r?void 0:r.container,this.iframe=this.createIframe()}var e=n.prototype;return e.createIframe=function(){var n=document.createElement(\"iframe\");return n.frameBorder=\"0\",n.width=\"0\",n.height=\"0\",n.src=this.host.href,n.sandbox.add(\"allow-scripts\"),n.sandbox.add(\"allow-same-origin\"),n.onload=this.iframeOnLoad.bind(this),this.container?this.container.append(n):document.body.append(n),this.options.useCompiled&&console.log(this.compiled),n},e.portOnMessage=function(){var n=r(a.mark(function n(e){var t,r,o,i;return a.wrap(function(n){for(;;)switch(n.prev=n.next){case 0:n.t0=e.data.type,n.next=\"events\"===n.t0?3:\"method\"===n.t0?7:22;break;case 3:return this.remoteMethods=e.data.api,this.createFunctions(),this.connected(),n.abrupt(\"break\",22);case 7:return n.prev=7,t=e.data.name,r=this.api[t],o=e.data.args,n.next=13,r.apply(null,o);case 13:i=n.sent,e.ports[0].postMessage({result:i}),n.next=21;break;case 17:n.prev=17,n.t1=n.catch(7),console.log(n.t1),e.ports[0].postMessage({error:n.t1});case 21:return n.abrupt(\"break\",22);case 22:case\"end\":return n.stop()}},n,this,[[7,17]])}));return function(e){return n.apply(this,arguments)}}(),e.iframeOnLoad=function(){var n,e,t=new MessageChannel;this.port=t.port1,this.port.onmessage=this.portOnMessage.bind(this);var r=[];for(var o in this.api)this.api.hasOwnProperty(o)&&r.push(o);null==(n=this.iframe.contentWindow)||n.postMessage({type:\"init\",api:r},this.remoteOrigin,[t.port2]),null==(e=this.iframe.contentWindow)||e.postMessage({type:\"init-eval\",data:this.code},this.remoteOrigin)},e.generateFunction=function(n){var e=this;return function(){for(var t=arguments.length,r=new Array(t),o=0;o<t;o++)r[o]=arguments[o];return new Promise(function(t,o){var a,i=new MessageChannel;i.port1.onmessage=function(n){var e=n.data;i.port1.close(),e.error?o(e.error):t(e.result)},null==(a=e.port)||a.postMessage({type:\"method\",name:n,args:r},[i.port2])})}},e.createFunctions=function(){var n=this;this.remoteMethods.forEach(function(e){n.child[e]=n.generateFunction(e)})},e.methodNameExists=function(n){var e=this;return new Promise(function(t,r){var o,a=new MessageChannel;a.port1.onmessage=function(n){var e=n.data;a.port1.close(),e.error?r(e.error):t(e.result)},null==(o=e.port)||o.postMessage({type:\"exists\",name:n},[a.port2])})},e.ready=function(n){this.isReady?n():this.readyFuncs.push(n)},e.connected=function(){this.isReady=!0,this.readyFuncs.forEach(function(n){n()})},n}();exports.PluginHost=i;var s={},c=function(){function n(n,e){this.hostMethods=[],window.addEventListener(\"message\",this.initPort.bind(this)),this.prepareFuncs=null==e?void 0:e.prepareFuncs,this.completeFuncs=null==e?void 0:e.completeFuncs,this.api=n}var e=n.prototype;return e.onMessage=function(){var n=r(a.mark(function n(e){var t,r,o,i,c;return a.wrap(function(n){for(;;)switch(n.prev=n.next){case 0:n.t0=e.data.type,n.next=\"method\"===n.t0?3:\"exists\"===n.t0?17:19;break;case 3:return n.prev=3,t=e.data.name,r=this.api[t],o=e.data.args,n.next=9,r.apply(null,o);case 9:i=n.sent,e.ports[0].postMessage({result:i}),n.next=16;break;case 13:n.prev=13,n.t1=n.catch(3),e.ports[0].postMessage({error:n.t1});case 16:return n.abrupt(\"break\",19);case 17:try{c=!!s[e.data.name],e.ports[0].postMessage({result:c})}catch(a){e.ports[0].postMessage({error:a})}return n.abrupt(\"break\",19);case 19:case\"end\":return n.stop()}},n,this,[[3,13]])}));return function(e){return n.apply(this,arguments)}}(),e.initializeApi=function(){var n,e=[];for(var t in this.api)this.api.hasOwnProperty(t)&&e.push(t);null==(n=this.port)||n.postMessage({type:\"events\",api:e})},e.generateFunction=function(n){var e=this;return function(){for(var t=arguments.length,r=new Array(t),o=0;o<t;o++)r[o]=arguments[o];return new Promise(function(t,o){var a,i=new MessageChannel;i.port1.onmessage=function(r){var a=r.data;if(i.port1.close(),a.error)o(a.error);else{var s=a.result;e.completeFuncs&&e.completeFuncs[n]&&(s=e.completeFuncs[n](s)),t(s)}},e.prepareFuncs&&e.prepareFuncs[n]&&(r=e.prepareFuncs[n](r)),null==(a=e.port)||a.postMessage({type:\"method\",name:n,args:r},[i.port2])})}},e.createFunctions=function(){var n=this;this.hostMethods.forEach(function(e){s[e]=n.generateFunction(e)})},e.initPort=function(n){var e;switch(n.data.type){case\"init\":this.port=n.ports[0],this.port.onmessage=this.onMessage.bind(this),this.hostMethods=n.data.api,this.initializeApi(),this.createFunctions();break;case\"init-eval\":var t=document.createElement(\"script\");t.innerHTML=n.data.data,null==(e=document.getElementById(\"head\"))||e.appendChild(t)}},n}();exports.PluginRemote=c;"},"sourceMaps":null,"error":null,"hash":"19d4b1a95bb603d5f36f363c6299cdcd","cacheData":{"env":{}}}